{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // return resolve({\n      //   SEARCHING: 'seraching internal datasource!',\n      //   INPUT,\n      //   SELF\n      // });\n      \n      // Reduce previous search results for next step\n      \n      console.log('reduce_search');\n      \n      let requestIndex = INPUT.requestIndex;\n      \n      \n      // await universe.historyLog({INPUT}, 'searching-internal-datasource', 'debug')\n      \n      // When searching: (permissions) \n      // - search is coming from a remote user (always!!!) \n      // - checking \"permission functions\" to determine what data to share \n      // - should already have created the AuthUser (in the universe.responsesCache) and other relevant permission information \n      \n      \n      // get all base (no nodeId) Nodes .... actually, get ALLLLLL Nodes! \n      // for each Node, run the permission functions \n      // - each child node (in the tree, go all the way down, recurse up!) \n      // after doing all child Nodes, do the parent Node \n      // - undefined means to leave it out \n      // - use universe.requestsCache for AuthUser, etc. \n      // after running all the permission functions, pass the Node to the parent \n      // return an array, without running any more analysis (do v2 locally) \n      \n      // permission functions are per-Node (stored as a type:permission_function that has a type:code as a NodeChild) \n      // permission functions are also per-Type, stored as a single Node for the type, of type:type_permission_function\n      \n      let startTime = (new Date()).getTime();\n      \n      let tmpRequestCache = await universe.getRequestCache({});\n      \n      console.log('--CODE for REDUCE:--'); //, INPUT.data.data.code);\n  \n      let reduceResult;\n      try {\n    \n        let strFunc = INPUT.data.data.code;\n        INPUT = {\n          type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n          data: {\n            inputNode:{}, // just uses requestCache for reducing \n            requestCache: tmpRequestCache\n          }\n        }\n        let miniverse = {\n          lodash: universe.lodash\n        }\n        // console.log('strFunc:',strFunc.length);\n        let transformedResult = eval(strFunc); // can't use Function cuz loses local scope\n        reduceResult = await Promise.resolve(transformedResult)\n        \n        \n        // reduceResult = await universe.runNodeCodeInVM({\n        //   codeNode: INPUT.data, // includes type/schemaName and data \n        //   dataNode: {\n        //     type: '...',\n        //     data: {}\n        //   }, // expecting to use requestCache for this \n        //   timeout: 25 * 1000\n        // });\n      }catch(err){\n        console.error('FAILED reduce_search', err);\n        return resolve({\n          type: 'error:Qmsdfsf',\n          data: {\n          }\n        });\n      }\n      \n      // // add output to request cache  \n      // let requestIndex = INPUT.requestIndex;\n      console.log('REDUCED OK123!', reduceResult ? true:false, reduceResult);\n      \n      await universe.setRequestCacheKeyValue('request' + requestIndex, reduceResult);\n      \n      return resolve({\n        type: 'array_of_strings:Qmdfljljsjfl823nf',\n        data: reduceResult\n      });\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "7090f3d5-3b0b-4c8f-9e44-c01ebf7da87f"
  }
}